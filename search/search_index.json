{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Halaman Tugas Komputasi Numerik Nama : Julius Agung S. NIM : 180411100024 Kelas : Komputasi Numerik 3C Prodi : Teknik Informatika Angkatan: 2018 Alamat: Perum Sumbertaman Indah Blok RE II No. 19 Kota Probolinggo","title":"home"},{"location":"#selamat-datang-di-halaman-tugas-komputasi-numerik","text":"Nama : Julius Agung S. NIM : 180411100024 Kelas : Komputasi Numerik 3C Prodi : Teknik Informatika Angkatan: 2018 Alamat: Perum Sumbertaman Indah Blok RE II No. 19 Kota Probolinggo","title":"Selamat Datang di Halaman Tugas Komputasi Numerik"},{"location":"MATERI%201%20%28Deret%20MCLAURIN%29/","text":"MATERI 1 (Deret MCLAURIN) Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor Definisi. dengan adalah Deret Taylor dan adalah sisa. dimana Dalam kasus khusus jika , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi. Deret Taylor atau Deret MacLaurin ini sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang susah dihitung secara manual seperti nilai , , , atau . Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin. f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 . . . f(n)(x) = ex f(n)(0) = 1 f(0) = 0 f'(x) = cos x f'(0) = 1 f\u201d(x) = -sin x f\u201d(0) = 0 f\u201d'(x) = -cos x f\u201d'(0) = -1 f(iv)(x) = sin x f(iv)(0) = 0 f(v)(x) = cos x f(v)(0) = 1 f(vi)(x) = -sin x f(vi)(0) = 0 f(vii)(x) = -cos x f(vii)(0) = -1 . . . f(x) = 0 + (1) + (0) + (-1) + (0) + (1) + (0) + (-1) + \u2026 f(0) = 1 f'(x) = -sin x f'(0) = 0 f\u201d(x) = -cos x f\u201d(0) = -1 f\u201d'(x) = sin x f\u201d'(0) = 0 f(iv)(x) = cos x f(iv)(0) = 1 f(v)(x) = -sin x f(v)(0) = 0 f(vi)(x) = -cos x f(vi)(0) = -1 f(vii)(x) = sin x f(vii)(0) = 0 . . . f(0) = ln(1) = 0 f'(x) = (x + 1)-1 f'(0) = 1 f\u201d(x) = -1(x + 1)-2 f'(0) = -1 = -1! f\u201d'(x) = 2(x + 1)-3 f'(0) = 2 = 2! f(iv)(x) = -6(x + 1)-4 f'(0) = -6 = -3! f(v) (x) = 24(x + 1)-5 f'(0) = 24 = 4! . . . untuk fungsi dengan basis 10, fungsi hampirannnya sama dengan fungsi . soal dan jawaban dalam bentuk code buatlah program yang dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) check = f_y - f_x a+=1 b+=1 print('iterasi ke-',a,'= ',check) output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Materi 1"},{"location":"MATERI%201%20%28Deret%20MCLAURIN%29/#materi-1-deret-mclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor Definisi. dengan adalah Deret Taylor dan adalah sisa. dimana Dalam kasus khusus jika , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi. Deret Taylor atau Deret MacLaurin ini sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang susah dihitung secara manual seperti nilai , , , atau . Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin. f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 . . . f(n)(x) = ex f(n)(0) = 1 f(0) = 0 f'(x) = cos x f'(0) = 1 f\u201d(x) = -sin x f\u201d(0) = 0 f\u201d'(x) = -cos x f\u201d'(0) = -1 f(iv)(x) = sin x f(iv)(0) = 0 f(v)(x) = cos x f(v)(0) = 1 f(vi)(x) = -sin x f(vi)(0) = 0 f(vii)(x) = -cos x f(vii)(0) = -1 . . . f(x) = 0 + (1) + (0) + (-1) + (0) + (1) + (0) + (-1) + \u2026 f(0) = 1 f'(x) = -sin x f'(0) = 0 f\u201d(x) = -cos x f\u201d(0) = -1 f\u201d'(x) = sin x f\u201d'(0) = 0 f(iv)(x) = cos x f(iv)(0) = 1 f(v)(x) = -sin x f(v)(0) = 0 f(vi)(x) = -cos x f(vi)(0) = -1 f(vii)(x) = sin x f(vii)(0) = 0 . . . f(0) = ln(1) = 0 f'(x) = (x + 1)-1 f'(0) = 1 f\u201d(x) = -1(x + 1)-2 f'(0) = -1 = -1! f\u201d'(x) = 2(x + 1)-3 f'(0) = 2 = 2! f(iv)(x) = -6(x + 1)-4 f'(0) = -6 = -3! f(v) (x) = 24(x + 1)-5 f'(0) = 24 = 4! . . . untuk fungsi dengan basis 10, fungsi hampirannnya sama dengan fungsi .","title":"MATERI 1 (Deret MCLAURIN)"},{"location":"MATERI%201%20%28Deret%20MCLAURIN%29/#soal-dan-jawaban-dalam-bentuk-code","text":"buatlah program yang dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) check = f_y - f_x a+=1 b+=1 print('iterasi ke-',a,'= ',check) output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"soal dan jawaban dalam bentuk code"},{"location":"MATERI%202%20%28Newton%20Raphson%29/","text":"Program Newton Raphson pada Fungsi Non Linear \u00b6 Pengertian Newton Raphson \u00b6 adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi $f(x)$ mempunyai turunan. Metode ini dianggap lebih mudah dari *Metode Bagi Dua* (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis imath ) yang menyinggung titik f(x_0) . Hal ini berakibat garis imath memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 sebagai berikut : Listing Program \u00b6 dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi(x): x = float((e**x) - (4*x)) return x def fungsiturunan(x): x = float((e**x) - (4)) return x x = float(input('Masukkan nilai awal = ')) error = float(input('Masukkan nilai error = ')) perulangan = int(input('Masukkan maksimal pengulangan = ')) iterasi = 0 selisih = error+1 while iterasi <= perulangan and selisih>error : iterasi += 1 f_2 = x - (fungsi(x)/fungsiturunan(x)) selisih = math.fabs(f_2 - x) x = f_2 print(\"Iterasi ke = \",iterasi,\", x = \",f_2, \", f(\",f_2,\") = \",fungsi(f_2),\", selisih = \",error) if iterasi <= perulangan: print(\"Perulangan Mencapai Batas Maksimal dengan hasil = \", f_2) else : print(\"Toleransi tidak terpenuhi\") Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f( 0.3574028224700733 ) = -6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Materi 2"},{"location":"MATERI%202%20%28Newton%20Raphson%29/#program-newton-raphson-pada-fungsi-non-linear","text":"","title":"Program Newton Raphson pada Fungsi Non Linear\u00b6"},{"location":"MATERI%202%20%28Newton%20Raphson%29/#pengertian-newton-raphson","text":"adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi $f(x)$ mempunyai turunan. Metode ini dianggap lebih mudah dari *Metode Bagi Dua* (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis imath ) yang menyinggung titik f(x_0) . Hal ini berakibat garis imath memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson","title":"Pengertian Newton Raphson\u00b6"},{"location":"MATERI%202%20%28Newton%20Raphson%29/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 sebagai berikut :","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson\u00b6"},{"location":"MATERI%202%20%28Newton%20Raphson%29/#listing-program","text":"dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi(x): x = float((e**x) - (4*x)) return x def fungsiturunan(x): x = float((e**x) - (4)) return x x = float(input('Masukkan nilai awal = ')) error = float(input('Masukkan nilai error = ')) perulangan = int(input('Masukkan maksimal pengulangan = ')) iterasi = 0 selisih = error+1 while iterasi <= perulangan and selisih>error : iterasi += 1 f_2 = x - (fungsi(x)/fungsiturunan(x)) selisih = math.fabs(f_2 - x) x = f_2 print(\"Iterasi ke = \",iterasi,\", x = \",f_2, \", f(\",f_2,\") = \",fungsi(f_2),\", selisih = \",error) if iterasi <= perulangan: print(\"Perulangan Mencapai Batas Maksimal dengan hasil = \", f_2) else : print(\"Toleransi tidak terpenuhi\") Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f( 0.3574028224700733 ) = -6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Listing Program\u00b6"},{"location":"MATERI%203%20%28Gauss%29/","text":"Eliminasi Gauss Jordan \u00b6 Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Materi 3"},{"location":"MATERI%203%20%28Gauss%29/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#_1","text":"","title":"\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#listing-program_1","text":"from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#program-gauss-seidel","text":"","title":"Program Gauss Seidel\u00b6"},{"location":"MATERI%203%20%28Gauss%29/#listing-program_2","text":"def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program\u00b6"},{"location":"MATERI%204%20%28Recursive%20Trapezoid%29/","text":"Recursive Trapezoid Recursive Trapezoid \u00b6 Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut : Estimasi berdasarkan satu interval Algoritma Integral Trapezoida \u00b6 Definisikan y = f(x) Tentukan batas bawah (a) dan batas atas (b) integrasi Tentukan jumlah pembagi n Hitung h = (b-a)/2 Hitung Listing Program \u00b6 Code program python untuk menyelesaikan integrasi numerik menggunakan metode Recursive Trapezoida dapat dibuat dengan listing program sebagai berikut : def fungsi(x): y = 1/(1+x) return y print(\"f(x) = 1/(1+x)\") a = float(input(\"Masukkan batas bawah: \")) b = float(input(\"Masukkan batas atas: \")) c = int(input(\"Masukkan n: \")) eror=[] print(\"iterasi\", \"\\t\",\"N\",\"\\t\\t\",\"Trapezoid\") for i in range(0,c): n=2**i h=(b-a)/n xi = a y=0 for j in range(1,n): xi+=h y+=fungsi(xi) trapezoid = ((h)*(fungsi(a)+(2*y)+fungsi(b)))/2 eror.append(trapezoid) print(i+1,\"\\t\\t\",n,\"\\t\\t\",trapezoid) hasil=(eror[-2]-eror[-1]) print(hasil) print(\"Estimasi Eror Adalah : \"+str(hasil)) Hasil Running List Program \u00b6","title":"Materi 4"},{"location":"MATERI%204%20%28Recursive%20Trapezoid%29/#recursive-trapezoid","text":"","title":"Recursive Trapezoid"},{"location":"MATERI%204%20%28Recursive%20Trapezoid%29/#recursive-trapezoid_1","text":"Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut : Estimasi berdasarkan satu interval","title":"Recursive Trapezoid\u00b6"},{"location":"MATERI%204%20%28Recursive%20Trapezoid%29/#algoritma-integral-trapezoida","text":"Definisikan y = f(x) Tentukan batas bawah (a) dan batas atas (b) integrasi Tentukan jumlah pembagi n Hitung h = (b-a)/2 Hitung","title":"Algoritma Integral Trapezoida\u00b6"},{"location":"MATERI%204%20%28Recursive%20Trapezoid%29/#listing-program","text":"Code program python untuk menyelesaikan integrasi numerik menggunakan metode Recursive Trapezoida dapat dibuat dengan listing program sebagai berikut : def fungsi(x): y = 1/(1+x) return y print(\"f(x) = 1/(1+x)\") a = float(input(\"Masukkan batas bawah: \")) b = float(input(\"Masukkan batas atas: \")) c = int(input(\"Masukkan n: \")) eror=[] print(\"iterasi\", \"\\t\",\"N\",\"\\t\\t\",\"Trapezoid\") for i in range(0,c): n=2**i h=(b-a)/n xi = a y=0 for j in range(1,n): xi+=h y+=fungsi(xi) trapezoid = ((h)*(fungsi(a)+(2*y)+fungsi(b)))/2 eror.append(trapezoid) print(i+1,\"\\t\\t\",n,\"\\t\\t\",trapezoid) hasil=(eror[-2]-eror[-1]) print(hasil) print(\"Estimasi Eror Adalah : \"+str(hasil))","title":"Listing Program\u00b6"},{"location":"MATERI%204%20%28Recursive%20Trapezoid%29/#hasil-running-list-program","text":"","title":"Hasil Running List Program\u00b6"},{"location":"MATERI%205%20%28Richardson%20Extrapolation%29/","text":"Richardson Extrapolation \u00b6 Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Teori \u00b6 Dalam rumus : *( f (x + h) - f (x - h) ) / (2 h)* untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K hn + o(hn) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n hn + o(hn) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2ne \u2212 e = 2na(h/2) \u2212 a(h) + K/2n hn \u2212 K hn + o(hn) Perhatikan bahwa istilah hn dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(hn) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn. Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h2, etc. Contoh Program \u00b6 from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<') print(\"=======================================================================\") print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print(\"=======================================================================\") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\"=======================================================================\") print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) Hasil Running \u00b6 >>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<< ======================================================================= f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.91250000000000530687 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 >>>","title":"Materi 5"},{"location":"MATERI%205%20%28Richardson%20Extrapolation%29/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa.","title":"Richardson Extrapolation\u00b6"},{"location":"MATERI%205%20%28Richardson%20Extrapolation%29/#teori","text":"Dalam rumus : *( f (x + h) - f (x - h) ) / (2 h)* untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K hn + o(hn) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n hn + o(hn) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2ne \u2212 e = 2na(h/2) \u2212 a(h) + K/2n hn \u2212 K hn + o(hn) Perhatikan bahwa istilah hn dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(hn) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn. Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h2, etc.","title":"Teori\u00b6"},{"location":"MATERI%205%20%28Richardson%20Extrapolation%29/#contoh-program","text":"from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<') print(\"=======================================================================\") print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print(\"=======================================================================\") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\"=======================================================================\") print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3))","title":"Contoh Program\u00b6"},{"location":"MATERI%205%20%28Richardson%20Extrapolation%29/#hasil-running","text":">>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<< ======================================================================= f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.91250000000000530687 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 >>>","title":"Hasil Running\u00b6"},{"location":"MATERI%206%20%28Metode%20Euler%29/","text":"Metode Euler \u00b6 Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini merupakan metode yang paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah dalam pemahamannya sehingga memudahkan dalam mempelajari metode lain yang lebih teliti. Metode euler atau disebut juga metode orde pertama karena persamaannya kita hanya mengambil sampai suku orde pertama saja. Misalnya diberikan Persamaan Diferensial Biasa orde satu, y=dydx=f(x,y)y=dydx=f(x,y) dan nilai awal y(x0)=y0y(x0)=y0 Dengan langkah h didefinisikan sebagai h=xn+1\u2212xnh=xn+1\u2212xn Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis yn+1=yn+hyn+1=yn+h x f(xn,yn)f(xn,yn) Contoh: Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa: dydx=1+x2dydx=1+x2 , y(1)=\u22124y(1)=\u22124 Untuk menentukan y(1.01), y(1.02) dan y(1.03). Source Code \u00b6 import numpy as np #Parameter untuk Euler y0 = -4 x0 = float(input(\"masukkan nilai x0 :\")) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range(1,n): hasil = y0 + h*(1 + (x0) ** 2) x0 += h y0 = hasil print(\"Langkah\"+str(i)+\": y\"+str(i)+\"= \"+ str(hasil)) Ouput \u00b6 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/Euler.py\" masukkan nilai x0 :1 Langkah1: y1= -3.98 Langkah2: y2= -3.959799 Langkah3: y3= -3.9393949999999998 Process finished with exit code 0","title":"Materi 6"},{"location":"MATERI%206%20%28Metode%20Euler%29/#metode-euler","text":"Metode Euler adalah salah satu dari metode satu langkah yang paling sederhana. Di banding dengan beberapa metode lainnya, metode ini merupakan metode yang paling kurang teliti. Namun demikian metode ini perlu dipelajari mengingat kesederhanaannya dan mudah dalam pemahamannya sehingga memudahkan dalam mempelajari metode lain yang lebih teliti. Metode euler atau disebut juga metode orde pertama karena persamaannya kita hanya mengambil sampai suku orde pertama saja. Misalnya diberikan Persamaan Diferensial Biasa orde satu, y=dydx=f(x,y)y=dydx=f(x,y) dan nilai awal y(x0)=y0y(x0)=y0 Dengan langkah h didefinisikan sebagai h=xn+1\u2212xnh=xn+1\u2212xn Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis yn+1=yn+hyn+1=yn+h x f(xn,yn)f(xn,yn) Contoh: Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa: dydx=1+x2dydx=1+x2 , y(1)=\u22124y(1)=\u22124 Untuk menentukan y(1.01), y(1.02) dan y(1.03).","title":"Metode Euler\u00b6"},{"location":"MATERI%206%20%28Metode%20Euler%29/#source-code","text":"import numpy as np #Parameter untuk Euler y0 = -4 x0 = float(input(\"masukkan nilai x0 :\")) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range(1,n): hasil = y0 + h*(1 + (x0) ** 2) x0 += h y0 = hasil print(\"Langkah\"+str(i)+\": y\"+str(i)+\"= \"+ str(hasil))","title":"Source Code\u00b6"},{"location":"MATERI%206%20%28Metode%20Euler%29/#ouput","text":"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/Euler.py\" masukkan nilai x0 :1 Langkah1: y1= -3.98 Langkah2: y2= -3.959799 Langkah3: y3= -3.9393949999999998 Process finished with exit code 0","title":"Ouput\u00b6"},{"location":"MATERI%207%20%28Monte%20Carlo%29/","text":"Metode Integral Monte Carlo \u00b6 Integral merupakan topik dalam kalkulus yang banyak diaplikasikan pada matematika maupun pada bidang-bidang lainnya terutama untuk pengembangan ilmu fisika maupun teknik. Perhitungan integral tentu fungsi kontinu pada selang tertutup termasuk dalam permasalahan deterministik. Model-model deterministik telah banyak dikembangkan untuk menyelesaikan permasalahan perhitungan integral tentu fungsi kontinu pada selang tertutup. Beberapa model tersebut antara lain adalah: Metode Romberg, Metode Trapesium, Metode Persegi Panjang dan metode \u2013 metode yang lain. Metode-metode tersebut termasuk dalam algoritma komputasional yang menggunakan proses deterministik karena menghasilkan keluaran yang pasti (bahkan bisa juga sama), setiap kali proses perhitungan dijalankan. Perhitungan integral yang termasuk permasalahan deterministik dapat juga diselesaikan dengan menggunakan pendekatan stokastik, salah satunya dengan menggunakan Metode Monte Carlo. Metode Monte Carlo (atau Percobaan Monte Carlo) merupakan salah satu kelas dalam algoritma komputasional yang menggunakan pengambilan sampel secara random untuk menghasilkan penyelesaian permasalahan. Metode Monte Carlo termasuk dalam model stokastik karena dikerjakan dengan menggunakan bilangan-bilangan random dan statistik probabilitas untuk menyelesaikan permasalahan-permasalahan. Metode Monte Carlo dapat juga digunakan untuk menyelesaiakan permasalahan-permasalahan pada bidang ekonomi, fisika, matematika maupun bidang-bidang yang lain. Contoh Soal \u00b6 soal nomer 3 adalah membuat program yang mana adalah implementasi dari monte carlo. dibawah ini adalah code programnya. from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N=2500 def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Nilai phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() Pada tiga baris pertama berfungsi untuk menginport library pada python. variabel a adalah batas bawah integral sedangkan variabel b merupakan batas atas integral dan variabel N adalah jumlah angka random yang akan kita coba ke dalam fungsi. def func(x):.. . mengandung fungsi integral dalam soal. main program terdapat dalam baris area=[] hingga baris area.append(jawab) . perulangan program akan dilakukan sebanyak N dengan memilih angka acak antara angka 0-2 dengan menggunakan for i in range(len(xrand[i])):... . kemudian semua hasil dari nilai komulatif fungsi akan ditampung dalam variabel integral. nilai phi akan dibuktikan dengan rumus monte carlo yakni (b-a)/N*integral . pada python untuk membuat diagram bisa menggunakan library matplotlib.pyplot. fungsi tersebud dijalankan menggunakan method pada code 4 baris terakhir dalam program. disini coba kita run program dan membuktikan berapa nilai phi sebenarnya. Percobaan pertama. Nilai phi menunjukkan senilai (3.1614507791715107) Percobaan kedua. nilai phi menunjukkan senilai (3.136555632439774) Percobaan ketiga. Nilai phi menunjukkan senilai(3.1260746164911244) Kesimpulannya,setelah dilakukan 3 kali percobaan nilai phi mendekati 3.14. Soal nomer 4 membuat program untuk menyelesaikan integral lipat tiga. dibawah ini adalah code untuk programnya. from scipy import random import numpy as np a = -1 b = 1 N=100 n=3 xrand=np.zeros(N) yrand=np.zeros(N) zrand=np.zeros(N) integral=0.0 for i in range(n+1): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jawab=(b-a)/float(N)*integral print(\"Hasil : \",jawab) Untuk programnya hampir sama dengan soal nomer 3 hanya saja ditambahkan variabel y dan z. Sehingga untuk mencari angka randomnya juga ditambahkan kedalam program. Dibawah ini terdapat 3 percobaan yang sudah saya lakukan. Percobaan gambar diatas terdapat 5 kali percobaan menunjukkan nilai antara 7.4-8.4. mari kita bandingkan dengan analisis secara manual pada gambar dibawah ini. Kesimpulan dari hasil analitis dan menggunakan program jawabannya hampir menekati. tergantung banyaknya angka yang diinputkan. semakin banyak jumlah N dalam monte carlo maka semakin sedikit estimasi erornya. Terima kasih.","title":"Materi 7"},{"location":"MATERI%207%20%28Monte%20Carlo%29/#metode-integral-monte-carlo","text":"Integral merupakan topik dalam kalkulus yang banyak diaplikasikan pada matematika maupun pada bidang-bidang lainnya terutama untuk pengembangan ilmu fisika maupun teknik. Perhitungan integral tentu fungsi kontinu pada selang tertutup termasuk dalam permasalahan deterministik. Model-model deterministik telah banyak dikembangkan untuk menyelesaikan permasalahan perhitungan integral tentu fungsi kontinu pada selang tertutup. Beberapa model tersebut antara lain adalah: Metode Romberg, Metode Trapesium, Metode Persegi Panjang dan metode \u2013 metode yang lain. Metode-metode tersebut termasuk dalam algoritma komputasional yang menggunakan proses deterministik karena menghasilkan keluaran yang pasti (bahkan bisa juga sama), setiap kali proses perhitungan dijalankan. Perhitungan integral yang termasuk permasalahan deterministik dapat juga diselesaikan dengan menggunakan pendekatan stokastik, salah satunya dengan menggunakan Metode Monte Carlo. Metode Monte Carlo (atau Percobaan Monte Carlo) merupakan salah satu kelas dalam algoritma komputasional yang menggunakan pengambilan sampel secara random untuk menghasilkan penyelesaian permasalahan. Metode Monte Carlo termasuk dalam model stokastik karena dikerjakan dengan menggunakan bilangan-bilangan random dan statistik probabilitas untuk menyelesaikan permasalahan-permasalahan. Metode Monte Carlo dapat juga digunakan untuk menyelesaiakan permasalahan-permasalahan pada bidang ekonomi, fisika, matematika maupun bidang-bidang yang lain.","title":"Metode Integral Monte Carlo\u00b6"},{"location":"MATERI%207%20%28Monte%20Carlo%29/#contoh-soal","text":"soal nomer 3 adalah membuat program yang mana adalah implementasi dari monte carlo. dibawah ini adalah code programnya. from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N=2500 def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Nilai phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() Pada tiga baris pertama berfungsi untuk menginport library pada python. variabel a adalah batas bawah integral sedangkan variabel b merupakan batas atas integral dan variabel N adalah jumlah angka random yang akan kita coba ke dalam fungsi. def func(x):.. . mengandung fungsi integral dalam soal. main program terdapat dalam baris area=[] hingga baris area.append(jawab) . perulangan program akan dilakukan sebanyak N dengan memilih angka acak antara angka 0-2 dengan menggunakan for i in range(len(xrand[i])):... . kemudian semua hasil dari nilai komulatif fungsi akan ditampung dalam variabel integral. nilai phi akan dibuktikan dengan rumus monte carlo yakni (b-a)/N*integral . pada python untuk membuat diagram bisa menggunakan library matplotlib.pyplot. fungsi tersebud dijalankan menggunakan method pada code 4 baris terakhir dalam program. disini coba kita run program dan membuktikan berapa nilai phi sebenarnya. Percobaan pertama. Nilai phi menunjukkan senilai (3.1614507791715107) Percobaan kedua. nilai phi menunjukkan senilai (3.136555632439774) Percobaan ketiga. Nilai phi menunjukkan senilai(3.1260746164911244) Kesimpulannya,setelah dilakukan 3 kali percobaan nilai phi mendekati 3.14. Soal nomer 4 membuat program untuk menyelesaikan integral lipat tiga. dibawah ini adalah code untuk programnya. from scipy import random import numpy as np a = -1 b = 1 N=100 n=3 xrand=np.zeros(N) yrand=np.zeros(N) zrand=np.zeros(N) integral=0.0 for i in range(n+1): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jawab=(b-a)/float(N)*integral print(\"Hasil : \",jawab) Untuk programnya hampir sama dengan soal nomer 3 hanya saja ditambahkan variabel y dan z. Sehingga untuk mencari angka randomnya juga ditambahkan kedalam program. Dibawah ini terdapat 3 percobaan yang sudah saya lakukan. Percobaan gambar diatas terdapat 5 kali percobaan menunjukkan nilai antara 7.4-8.4. mari kita bandingkan dengan analisis secara manual pada gambar dibawah ini. Kesimpulan dari hasil analitis dan menggunakan program jawabannya hampir menekati. tergantung banyaknya angka yang diinputkan. semakin banyak jumlah N dalam monte carlo maka semakin sedikit estimasi erornya. Terima kasih.","title":"Contoh Soal\u00b6"}]}